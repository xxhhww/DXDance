#pragma once
#include "Renderer/TerrainRenderer.h"
#include "Renderer/RingFrameTracker.h"
#include "Renderer/ResourceStateTracker.h"
#include "Renderer/LinearBufferAllocator.h"
#include "Renderer/PoolCommandListAllocator.h"
#include "Renderer/RuntimeVTAtlasTileCache.h"
#include "Renderer/RuntimeVTPageTable.h"

#include "Tools/ConcurrentQueue.h"

namespace Renderer {

	/*
	* 实时虚拟纹理调度请求
	*/
	struct RuntimeVTNodeRequestTask {
	public:
		RuntimeVTAtlasTileCache::Node* atlasNode{ nullptr };	// 一个图集元素

		// 前一任
		Math::Int2 prevPagePos{ -1, -1 };
		int32_t    prevPageLevel{ -1 };

		// 下一任
		Math::Int2 nextPagePos{ -1, -1 };
		int32_t    nextPageLevel{ -1 };
	};

	class RuntimeVTBackend {
	public:
		struct RecordedGpuCommand {
		public:
			GHL::CommandQueue* graphicsQueue{ nullptr };
			GHL::Fence*        graphicsFence{ nullptr };
			uint64_t           graphicsFenceExpectedValue{ 0u };

			GHL::CommandList*  updateRuntimeVTTextureAtlasCommandList{ nullptr };
			GHL::CommandList*  updateRuntimeVTPageTableCommandList{ nullptr };

			uint32_t           frameIndex{ 0u };
		};

	public:
		RuntimeVTBackend(TerrainRenderer* renderer, TerrainSetting& terrainSetting);

		~RuntimeVTBackend();

		// 预加载
		void Preload();

		void OnFrameLoading(uint32_t frameIndex);

		auto& GetRecordedGpuCommands() { return mRecordedGpuCommands; }

	private:
		// 后台线程
		void BackendThread();

		// 处理Feedback
		void ProcessTerrainFeedback(std::vector<RuntimeVTNodeRequestTask>& requestTasks, uint32_t completedFenceValue);

		// 录制GPU命令
		void RecordGpuCommand(std::vector<RuntimeVTNodeRequestTask>& requestTasks, RecordedGpuCommand& recordedGpuCommand);

		// 创建图形对象
		void CreateGraphicsObject();

		// 设置帧完成回调函数
		void SetupFrameCompletedCallBack();

		// 帧完成回调
		void OnFrameCompleted(uint8_t frameIndex);

	private:
		TerrainRenderer* mRenderer{ nullptr };

		// 着色器程序名称
		inline static std::string smUpdateRuntimeVTAtlasSN = "UpdateRuntimeVTAtlas";
		inline static std::string smUpdateRuntimeVTPageTableSN = "UpdateRuntimeVTPageTable";
		inline static uint32_t smMaxRvtFrameCount = 3u;

		// 线程同步变量
		std::thread mThread;
		HANDLE mHasPreloaded;
		bool mThreadRunning{ true };

		// 地形数据(From TerrainRenderer)
		TerrainSetting& mTerrainSetting;
		std::vector<RuntimeVTPageTable>& mRvtPageTables;

		std::unique_ptr<Renderer::BuddyHeapAllocator> mTerrainTiledSplatMapHeapAllocator;


		std::unique_ptr<GHL::CommandQueue>                  mRvtGraphicsQueue;
		std::unique_ptr<GHL::Fence>                         mRvtGraphicsFence;
		std::unique_ptr<Renderer::RingFrameTracker>	        mRvtFrameTracker;
		std::unique_ptr<Renderer::LinearBufferAllocator>    mRvtLinearBufferAllocator;
		std::unique_ptr<Renderer::PoolCommandListAllocator> mRvtCommandListAllocator;

		std::unique_ptr<Renderer::ResourceStateTracker>     mRvtResourceStateTracker;

		uint32_t   mQuadMeshVertexCountPerAxis;
		BufferWrap mQuadMeshVertexBuffer;
		BufferWrap mQuadMeshIndexBuffer;
		uint32_t   mQuadMeshIndexCount;

		struct UpdateRuntimeVTAtlasPassData {
		public:
			uint32_t drawRequestBufferIndex;
			uint32_t terrainSplatMapIndex;
			uint32_t terrainAlbedoTextureArrayIndex;
			uint32_t terrainNormalTextureArrayIndex;

			uint32_t terrainRoughnessTextureArrayIndex;
			float    pad1;
			float    pad2;
			float    pad3;
		};
		UpdateRuntimeVTAtlasPassData mUpdateRuntimeVTAtlasPassData;
		BufferWrap mUpdateRuntimeVTAtlasRequestBuffer;

		struct UpdateLookupPageTablePassData {
		public:

		};
		UpdateLookupPageTablePassData mUpdateLookupPageTablePassData;
		BufferWrap mUpdateLookupPageTableRequestBuffer;

		Tool::ConcurrentQueue<RecordedGpuCommand> mRecordedGpuCommands;										// 该队列由BackThread和MainThread共同访问

		std::vector<std::vector<RuntimeVTNodeRequestTask>> mReservedTerrainNodeRequestTasks;	// 预留的地形节点请求任务，以便帧完成后的回调处理

	};

}