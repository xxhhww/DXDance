#pragma once
#include "Renderer/ResourceAllocator.h"
#include "Renderer/RuntimeVirtualTextureSystem.h"
#include "Math/Int.h"

namespace Renderer {

	class RenderEngine;
	class RingFrameTracker;
	class RvtUpdater;
	class RuntimeVirtualTextureSystem;

	class TerrainSystem {
		friend class RvtUpdater;
		friend class RuntimeVirtualTextureSystem;

	public:
		struct NodeDescriptor {
			uint32_t isBranch = true;
			float pad1;
			float pad2;
			float pad3;
		};

		struct LODDescriptor {
			uint32_t nodeSize;			// 该LOD中每一个Node的边长(米)(Node是正方形)
			uint32_t nodeStartOffset;	// 该LOD中的第一个Node的开始偏移量
			uint32_t nodeCount;			// 该LOD中的Node的总个数
			float pad1;
		};

		struct TerrainBuilderPassData {
			Math::Vector4 nodeEvaluationC{ 1.2f, 0.0f, 0.0f, 0.0f };	// 用户控制的节点评估系数

			Math::Vector2 worldMeterSize{ 8192.0f, 8192.0f };				// 世界在XZ轴方向的大小(米)
			uint32_t heightScale{ 4096u };
			uint32_t currPassLOD;

			uint32_t consumeNodeListIndex;
			uint32_t appendNodeListIndex;
			uint32_t finalNodeListIndex;
			uint32_t nodeDescriptorListIndex;

			uint32_t lodDescriptorListIndex;
			uint32_t culledPatchListIndex;
			uint32_t minmaxHeightMapIndex;
			uint32_t useFrustumCull{ 0u };

			uint32_t nearbyNodeListIndex;
			float pad1;
			float pad2;
			float pad3;
		};

		struct TerrainRendererPassData {
			// x: page table size
			// y: virtual texture size
			// z: max mipmap level
			// w: mipmap level bias
			Math::Vector4 vtFeedbackParams{};
			Math::Vector4 vtRealRect{};
			// x: padding size
			// y: tileSize
			// z: physical texture size x
			// w: physical texture size y
			Math::Vector4 vtPhysicalMapParams{};

			Math::Vector2 worldMeterSize{ 8192.0f, 8192.0f };
			uint32_t heightScale{ 4096u };
			uint32_t culledPatchListIndex;

			uint32_t heightMapIndex;
			uint32_t normalMapIndex;
			uint32_t lodDebug{ 0u };
			uint32_t splatMapIndex;

			uint32_t pageTableMapIndex;
			uint32_t physicalAlbedoMapIndex;
			uint32_t physicalNormalMapIndex;
			float pad1;

			uint32_t rChannelAlbedoMapIndex;
			uint32_t rChannelNormalMapIndex;
			uint32_t rChannelRoughnessMapIndex;
			uint32_t rChannelHeightMapIndex;

			uint32_t gChannelAlbedoMapIndex;
			uint32_t gChannelNormalMapIndex;
			uint32_t gChannelRoughnessMapIndex;
			uint32_t gChannelHeightMapIndex;

			uint32_t bChannelAlbedoMapIndex;
			uint32_t bChannelNormalMapIndex;
			uint32_t bChannelRoughnessMapIndex;
			uint32_t bChannelHeightMapIndex;

			uint32_t aChannelAlbedoMapIndex;
			uint32_t aChannelNormalMapIndex;
			uint32_t aChannelRoughnessMapIndex;
			uint32_t aChannelHeightMapIndex;
		};

		struct NodeLocation {
			uint32_t x;
			uint32_t y;
		};

		struct RenderPatch {
			Math::Vector2 position;
			Math::Vector2 minMaxHeight;
			uint32_t lod;
			float pad1;
			float pad2;
			float pad3;
		};

	public:
		bool isInitialized{ false };
		Math::Vector2 worldMeterSize{ 8192.0f, 8192.0f };
		float worldHeightScale{ 4096.0f };
		bool lodDebug{ 0u };
		bool useVT{ 1u };

		uint32_t maxLOD{ 4u };	// 最大LOD等级
		uint32_t mostDetailNodeMeterSize{ 64u }; // 最精细的节点的大小(单位: 米)

		std::vector<NodeDescriptor> nodeDescriptors;
		std::vector<LODDescriptor>  lodDescriptors;
		std::vector<NodeLocation>   maxLODNodeList;
		TerrainBuilderPassData  terrainBuilderPassData;
		TerrainRendererPassData terrainRendererPassData;

		std::unique_ptr<Renderer::Mesh> patchMesh;
		TextureWrap minmaxHeightMap;
		TextureWrap terrainHeightMap;
		TextureWrap terrainNormalMap;

		TextureWrap terrainSplatMap;	// 纹理混合

		// channel R
		TextureWrap grassAlbedoMap;
		TextureWrap grassNormalMap;
		TextureWrap grassRoughnessMap;
		TextureWrap grassHeightMap;

		// channel G
		TextureWrap mudAlbedoMap;
		TextureWrap mudNormalMap;
		TextureWrap mudRoughnessMap;
		TextureWrap mudHeightMap;

		// channel B
		TextureWrap cliffAlbedoMap;
		TextureWrap cliffNormalMap;
		TextureWrap cliffRoughnessMap;
		TextureWrap cliffHeightMap;

		// channel A
		TextureWrap snowAlbedoMap;
		TextureWrap snowNormalMap;
		TextureWrap snowRoughness;
		TextureWrap snowHeightMap;

	public:
		TerrainSystem(RenderEngine* renderEngine);
		~TerrainSystem();

		/*
		* 地形初始化
		*/
		void Initialize(RenderEngine* renderEngine);

		/*
		* 添加TerrainPass至RenderGraph
		*/
		void AddPass(RenderEngine* renderEngine);

		/*
		* 渲染帧完成后的回调函数
		*/
		void FrameCompletedCallback(uint8_t frameIndex);

	private:
		void UpdateNodeAndLodDescriptorArray();

	private:
		RenderEngine* mRenderEngine{ nullptr };

		TextureWrap mTerrainFeedbackMap;
		struct QueuedReadbackFeedback {
		public:
			uint64_t renderFrameFenceValue{ 0u };	// 该变量由渲染主线程写入，ProcessFeedback线程只读
			std::atomic<bool> isFresh{ false };		// 该变量由渲染主线程与ProcessFeedback线程进行访问与修改
		};
		/*
		* 在每一个渲染帧完成后，渲染主线程都会更新QueuedReadbackFeedback这个结构体对象中的isFresh变量，并通知ProcessFeedback线程进行处理
		* 而在ProcessFeedback线程中，也会对isFresh变量进行修改
		*/
		std::vector<QueuedReadbackFeedback> mQueuedReadbacks;
		std::vector<BufferWrap> mTerrainReadbackBuffers;

		std::unique_ptr<RuntimeVirtualTextureSystem> mRvtSystem;
		// RvtUpdater* mRvtUpdater{ nullptr };
	};

}